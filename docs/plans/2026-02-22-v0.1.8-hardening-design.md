# v0.1.8 Hardening Release Design

**Date**: 2026-02-22
**Status**: Approved
**Purpose**: Final stabilisation before v0.2 (first stable release)

## Scope

One mandatory safety fix and three droppable stretch goals.
Priority order: P0 > P1 > P2 > P3. Each stretch goal is self-contained
and can be dropped without blocking the release.

## P0 (Mandatory): FFI Panic Boundary Guard

### Problem

All 42 `extern "C"` functions in murk-ffi lack `catch_unwind`. Any panic
(allocation failure, callback error, trampoline issue) crosses the FFI
boundary as undefined behaviour. The existing `ffi_lock!` macro only
handles mutex poisoning, not general panics.

### Design

**New macro: `ffi_guard!`**

Wraps function bodies in `std::panic::catch_unwind(AssertUnwindSafe(|| { ... }))`.
On panic, stores the panic message in a thread-local `String` and returns
`MurkStatus::Panicked`.

```rust
thread_local! {
    static LAST_PANIC: RefCell<String> = const { RefCell::new(String::new()) };
}

macro_rules! ffi_guard {
    ($body:expr) => {{
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| $body)) {
            Ok(ret) => ret,
            Err(payload) => {
                let msg = if let Some(s) = payload.downcast_ref::<&str>() {
                    (*s).to_owned()
                } else if let Some(s) = payload.downcast_ref::<String>() {
                    s.clone()
                } else {
                    "unknown panic".to_owned()
                };
                LAST_PANIC.with(|cell| *cell.borrow_mut() = msg);
                MurkStatus::Panicked as i32
            }
        }
    }};
}
```

**New status variant**: `MurkStatus::Panicked = -128`

Distinct from `InternalError` (which signals mutex poisoning). Allows
callers to distinguish "something panicked" from "a prior panic poisoned
a mutex".

**New FFI function**: `murk_last_panic_message`

```c
int32_t murk_last_panic_message(char *buf, size_t cap);
```

Copies the thread-local panic message into a caller-provided buffer.
Returns the actual message length (excluding null terminator), or 0 if
no panic has been recorded on this thread. Same pattern as
`murk_step_metrics_propagator`.

**ABI version**: Bump minor v2.0 -> v2.1 (additive: new status code + new function).

### Affected files

- `crates/murk-ffi/src/lib.rs` — macro definition, ABI version, new function
- `crates/murk-ffi/src/world.rs` — wrap 14 functions
- `crates/murk-ffi/src/config.rs` — wrap 9 functions
- `crates/murk-ffi/src/batched.rs` — wrap 9 functions
- `crates/murk-ffi/src/obs.rs` — wrap 6 functions
- `crates/murk-ffi/src/metrics.rs` — wrap 2 functions
- `crates/murk-ffi/src/propagator.rs` — wrap 1 function
- `crates/murk-ffi/src/status.rs` — add `Panicked` variant
- `crates/murk-ffi/include/murk.h` — regenerate (cbindgen picks up changes)
- `crates/murk-python/src/error.rs` — map `Panicked` to Python exception

### Testing

- Unit test: propagator callback that panics returns `Panicked` status,
  message retrievable via `murk_last_panic_message`.
- Unit test: normal operation unaffected (ffi_guard overhead is negligible).
- Python test: panicking propagator raises exception instead of crashing.

## P1 (Stretch): max_dt Topology Awareness

### Problem

`Propagator::max_dt(&self)` has no access to the Space. ScalarDiffusion
defaults to `max_degree=12` (Fcc12 worst-case), giving Square4 users a
3x more conservative CFL bound than necessary.

### Design

Change the trait signature directly (breaking change, acceptable for 0.1.x):

```rust
fn max_dt(&self, space: &dyn Space) -> Option<f64> {
    let _ = space;
    None
}
```

`validate_pipeline()` already has the space available and passes it through.
Existing propagators that don't need the space just ignore the parameter.

ScalarDiffusion uses it to derive max degree dynamically:

```rust
fn max_dt(&self, space: &dyn Space) -> Option<f64> {
    if self.coefficient <= 0.0 { return None; }
    let sample_idx = space.cell_count() / 2;
    let coords = space.canonical_ordering();
    let degree = space.neighbours(&coords[sample_idx]).len();
    let max_degree = degree.max(self.max_degree as usize);
    Some(1.0 / (max_degree as f64 * self.coefficient))
}
```

The builder `.max_degree()` stays as a floor/override.

### Affected files

- `crates/murk-propagator/src/propagator.rs` — new trait method
- `crates/murk-propagator/src/pipeline.rs` — call site change
- `crates/murk-propagators/src/scalar_diffusion.rs` — override

### Testing

- Test: ScalarDiffusion on Square4 returns `1/(4*D)` not `1/(12*D)`.
- Test: custom propagator without override still works via default.

## P2 (Stretch): Sparse Reuse Metrics

### Problem

`sparse_retired_ranges` and `sparse_pending_retired` show pool size but
not allocation effectiveness. Can't tell if ranges are being reused.

### Design

Add two `u32` counters to the metrics pipeline:

- `sparse_reuse_hits`: allocations served from the retired pool this tick
- `sparse_reuse_misses`: allocations that fell through to bump allocation

Wire through: `SparseSlab` -> `StepMetrics` -> `MurkStepMetrics` -> Python.

`MurkStepMetrics` grows from 48 to 56 bytes (4 x u32 sparse fields + padding).
Covered by the v2.1 ABI minor bump from P0.

### Affected files

- `crates/murk-arena/src/sparse.rs` — track hit/miss in alloc()
- `crates/murk-engine/src/metrics.rs` — new fields
- `crates/murk-ffi/src/metrics.rs` — extend repr(C) struct + size assertion
- `crates/murk-python/src/metrics.rs` — expose getters
- `crates/murk-ffi/include/murk.h` — regenerate

### Testing

- Unit test: alloc from retired pool increments hits.
- Unit test: alloc with no matching range increments misses.
- Python test: metrics dict includes new fields.

## P3 (Stretch): ProductSpace Semantic Documentation

### Problem

CR-1 flags that ProductSpace's composition semantics are correct but
undocumented. The formal contracts for how neighbours, distance, and
regions compose across heterogeneous topologies are implicit.

### Design

Add doc comments to `ProductSpace` and key methods:

- Struct-level: formal definition of the product graph
- `neighbours()`: varies one component at a time (product graph edge set)
- `metric_distance()`: per-metric semantics (L1 = sum, LInfinity = max,
  Weighted = validated weighted sum)
- `compile_region()`: Cartesian product of per-component region plans;
  BFS for Disk in product graph
- Edge behavior: per-component; Absorb/Wrap/Clamp applied independently

No code changes. ~100 lines of doc comments.

### Affected files

- `crates/murk-space/src/product.rs` — doc comments only

### Testing

None required (documentation only, behaviour unchanged).

## Release Checklist

1. P0: FFI panic boundary guard (mandatory)
2. P1: max_dt topology awareness (droppable)
3. P2: Sparse reuse metrics (droppable)
4. P3: ProductSpace semantic docs (droppable)
5. Update CHANGELOG.md
6. Update bug INDEX.md (close #53, #97)
7. Bump crate versions to 0.1.8
8. Tag `murk-v0.1.8`, push, verify release workflow
