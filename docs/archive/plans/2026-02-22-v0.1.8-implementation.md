# v0.1.8 Hardening Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Ship the final stabilisation release before v0.2 — FFI panic safety, topology-aware CFL, sparse observability, ProductSpace docs.

**Architecture:** Four independent work packages (P0-P3) executed in priority order. P0 is mandatory; P1-P3 are droppable stretch goals. Each package is self-contained with its own commit.

**Tech Stack:** Rust (stable, MSRV 1.87), PyO3, cbindgen, cargo test + miri

---

## Task 1: Add `MurkStatus::Panicked` variant

**Files:**
- Modify: `crates/murk-ffi/src/status.rs` (MurkStatus enum)

**Step 1: Write the failing test**

Add to the existing test module in `crates/murk-ffi/src/status.rs` (or `lib.rs` tests):

```rust
#[test]
fn panicked_status_is_negative_128() {
    assert_eq!(MurkStatus::Panicked as i32, -128);
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p murk-ffi -- panicked_status`
Expected: FAIL — `Panicked` variant doesn't exist

**Step 3: Write minimal implementation**

In `crates/murk-ffi/src/status.rs`, add to the `MurkStatus` enum:

```rust
    Panicked = -128,
```

After `UnsupportedCommand = -21`.

**Step 4: Run test to verify it passes**

Run: `cargo test -p murk-ffi -- panicked_status`
Expected: PASS

**Step 5: Commit**

```
feat(ffi): add MurkStatus::Panicked variant (-128)
```

---

## Task 2: Add `ffi_guard!` macro and `LAST_PANIC` thread-local

**Files:**
- Modify: `crates/murk-ffi/src/lib.rs` (add macro + thread-local + `murk_last_panic_message`)

**Step 1: Write the failing tests**

Add to the test module in `crates/murk-ffi/src/lib.rs`:

```rust
#[test]
fn ffi_guard_returns_inner_value_on_success() {
    let result = ffi_guard!(MurkStatus::Ok as i32);
    assert_eq!(result, 0);
}

#[test]
fn ffi_guard_catches_panic_and_returns_panicked() {
    let result = ffi_guard!({
        panic!("test panic message");
    });
    assert_eq!(result, MurkStatus::Panicked as i32);
}

#[test]
fn last_panic_message_stored_on_panic() {
    let _ = ffi_guard!({
        panic!("hello from test");
    });
    let mut buf = [0u8; 64];
    let len = murk_last_panic_message(
        buf.as_mut_ptr() as *mut std::ffi::c_char,
        buf.len(),
    );
    let msg = std::str::from_utf8(&buf[..len as usize]).unwrap();
    assert_eq!(msg, "hello from test");
}

#[test]
fn last_panic_message_returns_zero_when_no_panic() {
    // Clear any prior panic state.
    LAST_PANIC.with(|cell| cell.borrow_mut().clear());
    let len = murk_last_panic_message(std::ptr::null_mut(), 0);
    assert_eq!(len, 0);
}
```

**Step 2: Run tests to verify they fail**

Run: `cargo test -p murk-ffi -- ffi_guard last_panic`
Expected: FAIL — macro and function don't exist

**Step 3: Write implementation**

In `crates/murk-ffi/src/lib.rs`, add after the existing `ffi_lock!` macro:

```rust
use std::cell::RefCell;
use std::ffi::c_char;

thread_local! {
    /// Panic message from the most recent `ffi_guard!` catch on this thread.
    pub(crate) static LAST_PANIC: RefCell<String> = const { RefCell::new(String::new()) };
}

/// Wrap an FFI function body in `catch_unwind`.
///
/// On panic, stores the message in `LAST_PANIC` and returns
/// `MurkStatus::Panicked as i32`. The caller can retrieve the message
/// via `murk_last_panic_message`.
macro_rules! ffi_guard {
    ($body:expr) => {{
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| $body)) {
            Ok(ret) => ret,
            Err(payload) => {
                let msg = if let Some(s) = payload.downcast_ref::<&str>() {
                    (*s).to_owned()
                } else if let Some(s) = payload.downcast_ref::<String>() {
                    s.clone()
                } else {
                    "unknown panic".to_owned()
                };
                LAST_PANIC.with(|cell| *cell.borrow_mut() = msg);
                $crate::status::MurkStatus::Panicked as i32
            }
        }
    }};
}
```

Also add `murk_last_panic_message`:

```rust
/// Retrieve the panic message from the most recent `ffi_guard!` catch
/// on this thread.
///
/// Copies up to `cap - 1` bytes into `buf` and null-terminates.
/// Returns the full message length (excluding null), or 0 if no panic
/// has been recorded. If `buf` is null, returns the length without writing.
#[no_mangle]
#[allow(unsafe_code)]
pub extern "C" fn murk_last_panic_message(buf: *mut c_char, cap: usize) -> i32 {
    LAST_PANIC.with(|cell| {
        let msg = cell.borrow();
        if msg.is_empty() {
            return 0;
        }
        let bytes = msg.as_bytes();
        if !buf.is_null() && cap > 0 {
            let copy_len = bytes.len().min(cap - 1);
            unsafe {
                std::ptr::copy_nonoverlapping(bytes.as_ptr(), buf as *mut u8, copy_len);
                *buf.add(copy_len) = 0;
            }
        }
        bytes.len() as i32
    })
}
```

**Step 4: Run tests**

Run: `cargo test -p murk-ffi -- ffi_guard last_panic panicked_status`
Expected: ALL PASS

**Step 5: Commit**

```
feat(ffi): add ffi_guard! macro and murk_last_panic_message
```

---

## Task 3: Wrap all `extern "C"` functions with `ffi_guard!`

This is mechanical: wrap the body of every `extern "C"` function in `ffi_guard!({ ... })`.

**Files:**
- Modify: `crates/murk-ffi/src/world.rs` — 14 functions
- Modify: `crates/murk-ffi/src/config.rs` — 9 functions
- Modify: `crates/murk-ffi/src/batched.rs` — 9 functions
- Modify: `crates/murk-ffi/src/obs.rs` — 6 functions
- Modify: `crates/murk-ffi/src/metrics.rs` — 2 functions
- Modify: `crates/murk-ffi/src/propagator.rs` — 1 function

**Important:** Do NOT wrap `murk_abi_version` (trivial, no panic source) or `murk_last_panic_message` (must not recurse).

**Pattern for i32-returning functions (33 functions):**

Before:
```rust
pub extern "C" fn murk_lockstep_create(config_handle: u64, world_out: *mut u64) -> i32 {
    // ... body ...
}
```

After:
```rust
pub extern "C" fn murk_lockstep_create(config_handle: u64, world_out: *mut u64) -> i32 {
    ffi_guard!({
        // ... body ...
    })
}
```

**Pattern for non-i32 functions (8 legacy/info accessors):**

These return u64/u32/u8/usize/i64 and already use 0 or -1 as error sentinels.
Use a typed `ffi_guard_or!` variant or just wrap with `catch_unwind` returning default:

Before:
```rust
pub extern "C" fn murk_current_tick(world_handle: u64) -> u64 {
    get_world(world_handle)
        .and_then(|arc| arc.lock().ok().map(|w| w.current_tick().0))
        .unwrap_or(0)
}
```

After:
```rust
pub extern "C" fn murk_current_tick(world_handle: u64) -> u64 {
    match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        get_world(world_handle)
            .and_then(|arc| arc.lock().ok().map(|w| w.current_tick().0))
            .unwrap_or(0)
    })) {
        Ok(v) => v,
        Err(payload) => {
            let msg = if let Some(s) = payload.downcast_ref::<&str>() {
                (*s).to_owned()
            } else if let Some(s) = payload.downcast_ref::<String>() {
                s.clone()
            } else {
                "unknown panic".to_owned()
            };
            LAST_PANIC.with(|cell| *cell.borrow_mut() = msg);
            0 // sentinel: same as existing error return
        }
    }
}
```

To avoid duplication, add a second macro `ffi_guard_or!` that takes a default:

```rust
macro_rules! ffi_guard_or {
    ($default:expr, $body:expr) => {{
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| $body)) {
            Ok(ret) => ret,
            Err(payload) => {
                let msg = if let Some(s) = payload.downcast_ref::<&str>() {
                    (*s).to_owned()
                } else if let Some(s) = payload.downcast_ref::<String>() {
                    s.clone()
                } else {
                    "unknown panic".to_owned()
                };
                LAST_PANIC.with(|cell| *cell.borrow_mut() = msg);
                $default
            }
        }
    }};
}
```

Non-i32 functions use: `ffi_guard_or!(0, { ... })` or `ffi_guard_or!(-1, { ... })` for obs len functions.

**Step 1: Add `ffi_guard_or!` macro**

In `crates/murk-ffi/src/lib.rs`, add right after `ffi_guard!`.

**Step 2: Wrap all functions in world.rs (14 functions)**

Functions and their guard style:
- `murk_lockstep_create` (i32) → `ffi_guard!`
- `murk_lockstep_destroy` (i32) → `ffi_guard!`
- `murk_lockstep_step` (i32) → `ffi_guard!`
- `murk_lockstep_reset` (i32) → `ffi_guard!`
- `murk_snapshot_read_field` (i32) → `ffi_guard!`
- `murk_current_tick` (u64) → `ffi_guard_or!(0, ...)`
- `murk_current_tick_get` (i32) → `ffi_guard!`
- `murk_is_tick_disabled` (u8) → `ffi_guard_or!(0, ...)`
- `murk_is_tick_disabled_get` (i32) → `ffi_guard!`
- `murk_consecutive_rollbacks` (u32) → `ffi_guard_or!(0, ...)`
- `murk_consecutive_rollbacks_get` (i32) → `ffi_guard!`
- `murk_seed` (u64) → `ffi_guard_or!(0, ...)`
- `murk_seed_get` (i32) → `ffi_guard!`
- `murk_lockstep_step_vec` (i32) → `ffi_guard!`

**Step 3: Wrap all functions in config.rs (9 functions, all i32)** → `ffi_guard!`

**Step 4: Wrap all functions in batched.rs (9 functions)**

- 6 i32 functions → `ffi_guard!`
- `murk_batched_num_worlds` (usize) → `ffi_guard_or!(0, ...)`
- `murk_batched_obs_output_len` (usize) → `ffi_guard_or!(0, ...)`
- `murk_batched_obs_mask_len` (usize) → `ffi_guard_or!(0, ...)`

**Step 5: Wrap all functions in obs.rs (6 functions)**

- 4 i32 functions → `ffi_guard!`
- `murk_obsplan_output_len` (i64) → `ffi_guard_or!(-1, ...)`
- `murk_obsplan_mask_len` (i64) → `ffi_guard_or!(-1, ...)`

**Step 6: Wrap metrics.rs (2 functions, both i32)** → `ffi_guard!`

**Step 7: Wrap propagator.rs (1 function, i32)** → `ffi_guard!`

**Step 8: Run full test suite**

Run: `cargo test -p murk-ffi`
Expected: ALL PASS (existing behaviour unchanged)

**Step 9: Commit**

```
feat(ffi): wrap all 41 extern C functions with ffi_guard!/ffi_guard_or!
```

---

## Task 4: Bump ABI version to v2.1

**Files:**
- Modify: `crates/murk-ffi/src/lib.rs`

**Step 1: Update version constant and test**

Change `murk_abi_version` to return `(2 << 16) | 1` (v2.1).
Update test `abi_version_returns_v2_0` → `abi_version_returns_v2_1`:

```rust
pub extern "C" fn murk_abi_version() -> u32 {
    (2 << 16) | 1
}

#[test]
fn abi_version_returns_v2_1() {
    let v = murk_abi_version();
    assert_eq!(v >> 16, 2);
    assert_eq!(v & 0xFFFF, 1);
}
```

Also update the doc comment: `Current: v2.1 (v2.0→v2.1: ffi_guard! panic safety, murk_last_panic_message, MurkStatus::Panicked)`.

**Step 2: Run test**

Run: `cargo test -p murk-ffi -- abi_version`
Expected: PASS

**Step 3: Commit**

```
feat(ffi): bump ABI version to v2.1
```

---

## Task 5: Map `Panicked` status to Python exception

**Files:**
- Modify: `crates/murk-python/src/error.rs`

**Step 1: Find the status-to-exception mapping**

Look for where `MurkStatus` codes are mapped to Python exceptions (likely a `match` on the i32 return code). Add a branch for -128.

**Step 2: Add mapping**

Map `MurkStatus::Panicked` (-128) to a `RuntimeError` with the panic message. If `murk_last_panic_message` is accessible from Python, include its output in the exception message.

**Step 3: Run Python tests**

Run: `cargo test -p murk-python`
Expected: ALL PASS

**Step 4: Commit**

```
feat(python): map MurkStatus::Panicked to RuntimeError with message
```

---

## Task 6: Regenerate C header

**Files:**
- Regenerate: `crates/murk-ffi/include/murk.h`

**Step 1: Run cbindgen**

Check for a cbindgen config or build.rs that generates the header.
Run the generation command (likely `cbindgen --config cbindgen.toml --crate murk-ffi --output crates/murk-ffi/include/murk.h`).

**Step 2: Verify new items appear**

Check that `murk.h` includes:
- `MURK_PANICKED = -128` in the status enum
- `murk_last_panic_message(char *buf, size_t cap)` function declaration

**Step 3: Commit**

```
chore(ffi): regenerate murk.h with panic safety additions
```

---

## Task 7: P0 integration test — panicking propagator

**Files:**
- Modify: `crates/murk-ffi/src/propagator.rs` (test module) or a new integration test

**Step 1: Write test**

Create a test that registers a C callback propagator whose step function panics,
steps the world, and verifies:
1. `murk_lockstep_step` returns `MurkStatus::Panicked` (-128)
2. `murk_last_panic_message` returns a non-empty message
3. The world handle is still valid (mutex poisoned, so subsequent calls return `InternalError`)

**Step 2: Run test**

Run: `cargo test -p murk-ffi -- panicking_propagator`
Expected: PASS

**Step 3: Commit**

```
test(ffi): add integration test for panicking propagator callback
```

---

## Task 8: P1 — Change `max_dt` trait signature to accept `&dyn Space`

**Files:**
- Modify: `crates/murk-propagator/src/propagator.rs:96-102`
- Modify: `crates/murk-propagator/src/pipeline.rs:286` (call site)
- Modify: `crates/murk-propagator/src/pipeline.rs` (function signature + all test call sites)
- Modify: `crates/murk-engine/src/tick.rs:109` (call site)
- Modify: `crates/murk-engine/src/config.rs:306` (call site)

**Step 1: Update trait default**

In `crates/murk-propagator/src/propagator.rs`:

```rust
/// Maximum stable timestep for this propagator (e.g., CFL).
///
/// The pipeline validates `dt <= min(max_dt)` across all propagators.
/// Return `None` to impose no constraint. The `space` parameter
/// provides topology information (e.g., neighbour degree for CFL).
fn max_dt(&self, _space: &dyn murk_space::Space) -> Option<f64> {
    None
}
```

**Step 2: Update `validate_pipeline` signature**

In `crates/murk-propagator/src/pipeline.rs`, add `space: &dyn Space` parameter:

```rust
pub fn validate_pipeline(
    propagators: &[Box<dyn Propagator>],
    defined_fields: &FieldSet,
    dt: f64,
    space: &dyn Space,
) -> Result<ReadResolutionPlan, PipelineError> {
```

Update the dt validation loop (line 286):
```rust
if let Some(max) = prop.max_dt(space) {
```

**Step 3: Update all callers**

In `crates/murk-engine/src/tick.rs:109`:
```rust
let plan = murk_propagator::validate_pipeline(
    &config.propagators, &defined_fields, config.dt, &*config.space,
)?;
```

In `crates/murk-engine/src/config.rs:306`:
```rust
let _ = validate_pipeline(&self.propagators, &defined, self.dt, &*self.space)?;
```

**Step 4: Fix test call sites in pipeline.rs**

All ~27 test calls to `validate_pipeline` need a space argument. Add a helper at the top of the test module:

```rust
fn test_space() -> Box<dyn Space> {
    Box::new(murk_space::Square4::new(4, 4, murk_space::EdgeBehavior::Wrap))
}
```

Then update each call: `validate_pipeline(&props, &fields, 0.1, &*test_space())`

**Step 5: Update all `max_dt` implementations**

- `crates/murk-propagators/src/diffusion.rs` — add `_space: &dyn Space` parameter, keep existing body
- `crates/murk-propagators/src/scalar_diffusion.rs` — add `space: &dyn Space` parameter (will use it in Task 9)
- `crates/murk-ffi/src/propagator.rs` (CallbackPropagator) — if it overrides `max_dt`, add the parameter; if it uses the default, nothing to do

**Step 6: Run full workspace test**

Run: `cargo test --workspace`
Expected: ALL PASS

**Step 7: Commit**

```
refactor(propagator): add space parameter to max_dt trait method
```

---

## Task 9: P1 — ScalarDiffusion topology-aware CFL

**Files:**
- Modify: `crates/murk-propagators/src/scalar_diffusion.rs`
- Test: same file (test module)

**Step 1: Write the failing test**

```rust
#[test]
fn max_dt_uses_space_degree_for_square4() {
    let prop = ScalarDiffusion::builder()
        .coefficient(1.0)
        .build();
    let space = murk_space::Square4::new(8, 8, murk_space::EdgeBehavior::Wrap);
    // Square4 has degree 4, so CFL bound = 1/(4*1.0) = 0.25
    let dt = prop.max_dt(&space);
    assert_eq!(dt, Some(0.25));
}

#[test]
fn max_dt_uses_space_degree_for_hex2d() {
    let prop = ScalarDiffusion::builder()
        .coefficient(1.0)
        .build();
    let space = murk_space::Hex2D::new(4, murk_space::EdgeBehavior::Wrap);
    // Hex2D has degree 6, so CFL bound = 1/(6*1.0) ≈ 0.1667
    let dt = prop.max_dt(&space);
    assert!((dt.unwrap() - 1.0 / 6.0).abs() < 1e-10);
}

#[test]
fn max_degree_builder_acts_as_floor() {
    let prop = ScalarDiffusion::builder()
        .coefficient(1.0)
        .max_degree(8) // higher than Square4's 4
        .build();
    let space = murk_space::Square4::new(8, 8, murk_space::EdgeBehavior::Wrap);
    // Builder max_degree (8) > space degree (4), so use 8
    let dt = prop.max_dt(&space);
    assert_eq!(dt, Some(1.0 / 8.0));
}
```

**Step 2: Run tests to verify they fail**

Run: `cargo test -p murk-propagators -- max_dt_uses_space`
Expected: FAIL — ScalarDiffusion still uses hardcoded max_degree, ignoring space

**Step 3: Implement**

In `crates/murk-propagators/src/scalar_diffusion.rs`, update the `max_dt` implementation:

```rust
fn max_dt(&self, space: &dyn murk_space::Space) -> Option<f64> {
    if self.coefficient <= 0.0 {
        return None;
    }
    // Sample a central cell to determine the space's connectivity degree.
    let n = space.cell_count();
    if n == 0 {
        return None;
    }
    let ordering = space.canonical_ordering();
    let sample = &ordering[n / 2];
    let space_degree = space.neighbours(sample).len() as u32;
    // Use the greater of the space's actual degree and the builder's floor.
    let effective_degree = space_degree.max(self.max_degree);
    Some(1.0 / (effective_degree as f64 * self.coefficient))
}
```

**Step 4: Run tests**

Run: `cargo test -p murk-propagators -- max_dt`
Expected: ALL PASS

**Step 5: Also update DiffusionPropagator (deprecated)**

In `crates/murk-propagators/src/diffusion.rs`, update its `max_dt` similarly (add `space` param, use space degree instead of hardcoded 12).

**Step 6: Run full workspace test**

Run: `cargo test --workspace`
Expected: ALL PASS

**Step 7: Commit**

```
feat(propagators): ScalarDiffusion derives CFL bound from space topology
```

---

## Task 10: P2 — Add sparse reuse counters to SparseSlab

**Files:**
- Modify: `crates/murk-arena/src/sparse.rs` (SparseSlab struct + alloc method)

**Step 1: Write the failing tests**

```rust
#[test]
fn reuse_hit_counted_on_retired_match() {
    // Set up a SparseSlab, alloc, free, alloc same size
    // Assert reuse_hits == 1, reuse_misses == 0
}

#[test]
fn reuse_miss_counted_on_no_match() {
    // Set up a SparseSlab, alloc with no retired ranges
    // Assert reuse_hits == 0, reuse_misses == 1
}
```

The exact test bodies depend on SparseSlab's constructor and method signatures — the implementing agent should read the file and write appropriate tests.

**Step 2: Add fields to SparseSlab**

```rust
reuse_hits: u32,
reuse_misses: u32,
```

Initialize to 0 in constructor. Increment `reuse_hits` in the `if let Some(pos)` branch of `alloc()`, increment `reuse_misses` in the `else` branch. Add getter methods:

```rust
pub fn reuse_hits(&self) -> u32 { self.reuse_hits }
pub fn reuse_misses(&self) -> u32 { self.reuse_misses }
```

Add a `reset_reuse_counters(&mut self)` method (called at start of each tick to get per-tick counts).

**Step 3: Run tests**

Run: `cargo test -p murk-arena -- reuse`
Expected: PASS

**Step 4: Commit**

```
feat(arena): track sparse reuse hits/misses in SparseSlab
```

---

## Task 11: P2 — Wire reuse metrics through engine and FFI

**Files:**
- Modify: `crates/murk-engine/src/metrics.rs` — add fields
- Modify: `crates/murk-engine/src/tick.rs` — populate fields
- Modify: `crates/murk-ffi/src/metrics.rs` — extend MurkStepMetrics
- Modify: `crates/murk-python/src/metrics.rs` — expose getters

**Step 1: Add to StepMetrics**

In `crates/murk-engine/src/metrics.rs`:

```rust
pub sparse_reuse_hits: u32,
pub sparse_reuse_misses: u32,
```

**Step 2: Populate in tick.rs**

In the StepMetrics construction (~line 355):

```rust
sparse_reuse_hits: self.arena.sparse_reuse_hits() as u32,
sparse_reuse_misses: self.arena.sparse_reuse_misses() as u32,
```

(The PingPongArena needs to expose these by delegating to its SparseSlab.)

**Step 3: Extend MurkStepMetrics**

In `crates/murk-ffi/src/metrics.rs`, add two fields after `sparse_pending_retired`:

```rust
pub sparse_reuse_hits: u32,
pub sparse_reuse_misses: u32,
```

Update size assertion: `48 → 56` bytes (3×u64=24 + 1×u64=8 + 5×u32=20 + 4 padding = 56).
Update `from_rust` to map the new fields.

**Step 4: Extend Python StepMetrics**

In `crates/murk-python/src/metrics.rs`:
- Add fields
- Add getter methods
- Add to `to_dict()`
- Update `__repr__`

**Step 5: Run full test suite**

Run: `cargo test --workspace`
Expected: ALL PASS

**Step 6: Commit**

```
feat(metrics): wire sparse reuse hits/misses through engine, FFI, Python
```

---

## Task 12: P3 — ProductSpace semantic documentation

**Files:**
- Modify: `crates/murk-space/src/product.rs` (doc comments only)

**Step 1: Add struct-level documentation**

Replace or extend the `ProductSpace` struct doc comment with formal semantics:
- Definition: Cartesian product of N component spaces
- Coordinate representation: concatenation of per-component coords
- Cell count: product of component cell counts

**Step 2: Document `neighbours()`**

Formal edge-set definition: the product graph varies one component at a time.

**Step 3: Document `metric_distance()`**

Per-metric: L1 (sum), LInfinity (max), Weighted (validated weighted sum).

**Step 4: Document `compile_region()`**

Cartesian product for Rect/Coords; BFS in product graph for Disk.

**Step 5: Document edge behavior composition**

Per-component, independently applied.

**Step 6: Run doc tests**

Run: `cargo test -p murk-space --doc`
Expected: PASS (no code changes)

**Step 7: Commit**

```
docs(space): add formal semantic contracts to ProductSpace (CR-1)
```

---

## Task 13: Update CHANGELOG and version bumps

**Files:**
- Modify: `CHANGELOG.md`
- Modify: all `Cargo.toml` files (version 0.1.7 → 0.1.8)
- Modify: `docs/bugs/INDEX.md` (close #53, update #97)

**Step 1: Add 0.1.8 section to CHANGELOG.md**

```markdown
## [0.1.8] - 2026-02-22

FFI panic safety hardening and observability improvements.

### Added

- `ffi_guard!` macro: all 41 `extern "C"` functions wrapped in `catch_unwind`
- `MurkStatus::Panicked` (-128) error code for caught panics
- `murk_last_panic_message()` FFI function for panic diagnostics
- `Propagator::max_dt()` now receives `&dyn Space` for topology-aware CFL bounds
- `sparse_reuse_hits` and `sparse_reuse_misses` metrics in StepMetrics/FFI/Python
- Formal semantic documentation for ProductSpace (CR-1)

### Changed

- ABI version bumped from v2.0 to v2.1
- `MurkStepMetrics` layout: 48 → 56 bytes (added reuse counters)
- `ScalarDiffusion` CFL bound derived from space topology (no longer defaults to 12-neighbour worst-case)
- `validate_pipeline()` signature extended with `space: &dyn Space` parameter
```

**Step 2: Bump versions**

Run: `cargo set-version 0.1.8` or manually update each crate's `Cargo.toml`.

**Step 3: Update bug INDEX.md**

- Bug #53: mark as closed (cbindgen already shipped in 0.1.7)
- Bug #97: mark as closed if P2 lands, otherwise note partial fix

**Step 4: Run full test suite**

Run: `cargo test --workspace`
Expected: ALL PASS

**Step 5: Commit**

```
chore: bump workspace to v0.1.8, update CHANGELOG
```

---

## Task 14: Final verification

**Step 1: Full CI-equivalent check**

```bash
cargo check --workspace
cargo clippy --workspace -- -D warnings
cargo fmt --check
cargo test --workspace
```

**Step 2: Miri check**

```bash
cargo +nightly miri test -p murk-arena
```

**Step 3: Python tests**

```bash
cd crates/murk-python && maturin develop && pytest
```

All must pass before tagging.
