/* murk.h — Auto-generated by cbindgen. DO NOT EDIT.
 *
 * C FFI bindings for the Murk simulation framework.
 * See https://github.com/johnryan/murk for documentation.
 */

#ifndef MURK_H
#define MURK_H

/* Warning: this file is autogenously generated by cbindgen. Do not modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

/**
 * Boundary behavior when field values exceed bounds.
 */
enum MurkBoundaryBehavior {
  /**
   * Clamp to nearest bound.
   */
  Clamp = 0,
  /**
   * Reflect off the bound.
   */
  Reflect = 1,
  /**
   * Absorb at the boundary.
   */
  Absorb = 2,
  /**
   * Wrap around to opposite bound.
   */
  Wrap = 3,
};
typedef int32_t MurkBoundaryBehavior;

/**
 * Command type discriminator.
 */
enum MurkCommandType {
  /**
   * Set a global scalar parameter.
   */
  SetParameter = 0,
  /**
   * Set a single field value at a coordinate.
   */
  SetField = 1,
};
typedef int32_t MurkCommandType;

/**
 * Edge behavior for 1D/2D lattice spaces.
 */
enum MurkEdgeBehavior {
  /**
   * Absorb: cells at edge have no neighbor beyond.
   */
  Absorb = 0,
  /**
   * Clamp: beyond-edge neighbors map to edge cell.
   */
  Clamp = 1,
  /**
   * Wrap: periodic boundary.
   */
  Wrap = 2,
};
typedef int32_t MurkEdgeBehavior;

/**
 * Field allocation strategy across ticks.
 */
enum MurkFieldMutability {
  /**
   * Generation 0 forever.
   */
  Static = 0,
  /**
   * New allocation each tick if modified.
   */
  PerTick = 1,
  /**
   * New allocation only when modified.
   */
  Sparse = 2,
};
typedef int32_t MurkFieldMutability;

/**
 * Field data type classification.
 */
enum MurkFieldType {
  /**
   * Single f32 per cell.
   */
  Scalar = 0,
  /**
   * Fixed-size f32 vector per cell.
   */
  Vector = 1,
  /**
   * Categorical (discrete) value per cell.
   */
  Categorical = 2,
};
typedef int32_t MurkFieldType;

/**
 * Spatial topology type for `murk_config_set_space`.
 */
enum MurkSpaceType {
  /**
   * 1D line with configurable edge behavior.
   */
  Line1D = 0,
  /**
   * 1D ring (always-wrap periodic boundary).
   */
  Ring1D = 1,
  /**
   * 2D grid, 4-connected (N/S/E/W).
   */
  Square4 = 2,
  /**
   * 2D grid, 8-connected (+ diagonals).
   */
  Square8 = 3,
  /**
   * 2D hexagonal lattice, 6-connected (pointy-top).
   */
  Hex2D = 4,
  /**
   * Cartesian product of arbitrary spaces.
   */
  ProductSpace = 5,
  /**
   * 3D FCC lattice, 12-connected (isotropic).
   */
  Fcc12 = 6,
};
typedef int32_t MurkSpaceType;

/**
 * C-compatible status code returned by all FFI functions.
 *
 * `Ok` = 0, all errors are negative. Values are ABI-stable.
 */
enum MurkStatus {
  /**
   * Success.
   */
  Ok = 0,
  /**
   * Handle is invalid or was already destroyed.
   */
  InvalidHandle = -1,
  /**
   * Observation plan was compiled for a different generation.
   */
  PlanInvalidated = -2,
  /**
   * Exact-tick egress request timed out (RealtimeAsync only).
   */
  TimeoutWaitingForTick = -3,
  /**
   * Requested tick evicted from ring buffer.
   */
  NotAvailable = -4,
  /**
   * ObsPlan valid_ratio below threshold.
   */
  InvalidComposition = -5,
  /**
   * Command queue at capacity.
   */
  QueueFull = -6,
  /**
   * Command basis_tick_id is too old.
   */
  Stale = -7,
  /**
   * Tick was rolled back.
   */
  TickRollback = -8,
  /**
   * Arena allocation failed (OOM).
   */
  AllocationFailed = -9,
  /**
   * A propagator's step function failed.
   */
  PropagatorFailed = -10,
  /**
   * Observation plan execution failed mid-fill.
   */
  ExecutionFailed = -11,
  /**
   * Malformed ObsSpec at compilation time.
   */
  InvalidObsSpec = -12,
  /**
   * dt exceeds a propagator's max_dt constraint.
   */
  DtOutOfRange = -13,
  /**
   * Egress worker exceeded max_epoch_hold.
   */
  WorkerStalled = -14,
  /**
   * World is shutting down.
   */
  ShuttingDown = -15,
  /**
   * Ticking disabled after consecutive rollbacks.
   */
  TickDisabled = -16,
  /**
   * Configuration validation error.
   */
  ConfigError = -17,
  /**
   * An argument is null, out of range, or otherwise invalid.
   */
  InvalidArgument = -18,
  /**
   * Caller-provided buffer is too small.
   */
  BufferTooSmall = -19,
  /**
   * Internal error (e.g. poisoned mutex after a prior panic).
   */
  InternalError = -20,
  /**
   * Command type not supported by the tick executor.
   */
  UnsupportedCommand = -21,
  /**
   * A Rust panic was caught at the FFI boundary.
   */
  Panicked = -128,
};
typedef int32_t MurkStatus;

/**
 * Write initialization strategy.
 */
enum MurkWriteMode {
  /**
   * Fresh buffer — propagator must fill every cell.
   */
  Full = 0,
  /**
   * Seeded from previous generation; propagator updates selectively.
   */
  Incremental = 1,
};
typedef int32_t MurkWriteMode;

/**
 * C-compatible observation entry for plan compilation.
 *
 * Region type values:
 * - 0: All (whole grid)
 * - 5: AgentDisk (radius in `region_params[0]`)
 * - 6: AgentRect (half-extents in `region_params[0..n_region_params]`)
 *
 * Pool kernel values:
 * - 0: None (no pooling)
 * - 1: Mean
 * - 2: Max
 * - 3: Min
 * - 4: Sum
 */
typedef struct MurkObsEntry {
  /**
   * Field ID to observe.
   */
  uint32_t field_id;
  /**
   * Region type: 0=All, 5=AgentDisk, 6=AgentRect.
   */
  int32_t region_type;
  /**
   * Transform type: 0 = Identity, 1 = Normalize.
   */
  int32_t transform_type;
  /**
   * Lower bound for Normalize transform.
   */
  float normalize_min;
  /**
   * Upper bound for Normalize transform.
   */
  float normalize_max;
  /**
   * Output data type: 0 = F32.
   */
  int32_t dtype;
  /**
   * Region parameters (interpretation depends on region_type).
   */
  int32_t region_params[8];
  /**
   * Number of valid entries in `region_params`.
   */
  int32_t n_region_params;
  /**
   * Pooling kernel: 0=None, 1=Mean, 2=Max, 3=Min, 4=Sum.
   */
  int32_t pool_kernel;
  /**
   * Pooling window size (ignored if pool_kernel == 0).
   */
  int32_t pool_kernel_size;
  /**
   * Pooling stride (ignored if pool_kernel == 0).
   */
  int32_t pool_stride;
} MurkObsEntry;

/**
 * Flat C-compatible command struct.
 *
 * Fields are interpreted based on `command_type`. Unused fields are ignored.
 */
typedef struct MurkCommand {
  /**
   * Command variant (0 = SetParameter, 1 = SetField).
   * Stored as raw i32 to prevent UB from invalid C discriminators.
   */
  int32_t command_type;
  /**
   * Command expires if not applied by this tick.
   */
  uint64_t expires_after_tick;
  /**
   * Optional source identifier (0 = none).
   */
  uint64_t source_id;
  /**
   * Optional per-source sequence number (0 = none).
   */
  uint64_t source_seq;
  /**
   * Priority class (lower = higher priority).
   */
  uint8_t priority_class;
  /**
   * Field ID (SetField).
   */
  uint32_t field_id;
  /**
   * Parameter key (SetParameter).
   */
  uint32_t param_key;
  /**
   * Float value (SetField).
   */
  float float_value;
  /**
   * Double value (SetParameter).
   */
  double double_value;
  /**
   * Coordinate (SetField, up to 4D).
   */
  int32_t coord[4];
  /**
   * Number of coordinate dimensions used (SetField).
   */
  uint32_t coord_ndim;
} MurkCommand;

/**
 * C-compatible step metrics returned from `murk_lockstep_step`.
 */
typedef struct MurkStepMetrics {
  /**
   * Wall-clock time for the entire tick, in microseconds.
   */
  uint64_t total_us;
  /**
   * Time spent processing the ingress command queue, in microseconds.
   */
  uint64_t command_processing_us;
  /**
   * Time spent publishing the snapshot, in microseconds.
   */
  uint64_t snapshot_publish_us;
  /**
   * Memory usage of the arena after the tick, in bytes.
   * Fixed-width `u64` for ABI portability (not `usize`).
   */
  uint64_t memory_bytes;
  /**
   * Number of propagators executed.
   */
  uint32_t n_propagators;
  /**
   * Number of sparse segment ranges available for reuse.
   */
  uint32_t sparse_retired_ranges;
  /**
   * Number of sparse segment ranges pending promotion (freed this tick).
   */
  uint32_t sparse_pending_retired;
  /**
   * Number of sparse alloc() calls that reused a retired range this tick.
   */
  uint32_t sparse_reuse_hits;
  /**
   * Number of sparse alloc() calls that fell through to bump allocation this tick.
   */
  uint32_t sparse_reuse_misses;
  /**
   * Cumulative number of ingress rejections due to full queue.
   */
  uint64_t queue_full_rejections;
  /**
   * Cumulative number of ingress rejections due to tick-disabled state.
   */
  uint64_t tick_disabled_rejections;
  /**
   * Cumulative number of rollback events.
   */
  uint64_t rollback_events;
  /**
   * Cumulative number of transitions into tick-disabled state.
   */
  uint64_t tick_disabled_transitions;
  /**
   * Cumulative number of worker stall force-unpin events.
   */
  uint64_t worker_stall_events;
  /**
   * Cumulative number of ring "not available" events.
   */
  uint64_t ring_not_available_events;
} MurkStepMetrics;

/**
 * Result metadata from observation plan execution.
 */
typedef struct MurkObsResult {
  /**
   * Tick at which the observed snapshot was produced.
   */
  uint64_t tick_id;
  /**
   * Age of the snapshot relative to the current engine tick.
   */
  uint64_t age_ticks;
} MurkObsResult;

/**
 * Write declaration: (field_id, write_mode) pair.
 */
typedef struct MurkWriteDecl {
  /**
   * Field ID to write.
   */
  uint32_t field_id;
  /**
   * Write mode (0 = Full, 1 = Incremental).
   * Stored as raw i32 to prevent UB from invalid C discriminators.
   */
  int32_t mode;
} MurkWriteDecl;

/**
 * C-side step context — flat struct with function pointers for field access.
 *
 * Passed to the C `step_fn` callback. The `opaque` pointer wraps the
 * Rust `StepContext` internals; C code accesses fields through the
 * provided function pointers.
 */
typedef struct MurkStepContext {
  /**
   * Opaque pointer to internal wrapper (do not dereference in C).
   */
  void *opaque;
  /**
   * Read current-tick field data: `(opaque, field_id, out_ptr, out_len) -> status`.
   */
  int32_t (*read_fn)(void*, uint32_t, const float**, uintptr_t*);
  /**
   * Read previous-tick field data.
   */
  int32_t (*read_previous_fn)(void*, uint32_t, const float**, uintptr_t*);
  /**
   * Get mutable write buffer: `(opaque, field_id, out_ptr, out_len) -> status`.
   */
  int32_t (*write_fn)(void*, uint32_t, float**, uintptr_t*);
  /**
   * Current tick ID.
   */
  uint64_t tick_id;
  /**
   * Simulation timestep.
   */
  double dt;
  /**
   * Number of cells in the space.
   * Fixed-width `u64` for ABI portability (not `usize`).
   */
  uint64_t cell_count;
} MurkStepContext;

/**
 * C-side propagator definition with function pointers.
 *
 * Caller must ensure all pointers remain valid until the propagator is
 * consumed by `murk_config_add_propagator`. After consumption, only
 * `step_fn` and `user_data` must remain valid for the world's lifetime.
 */
typedef struct MurkPropagatorDef {
  /**
   * Null-terminated propagator name.
   */
  const char *name;
  /**
   * Array of field IDs this propagator reads (current tick).
   */
  const uint32_t *reads;
  /**
   * Length of `reads` array.
   */
  uintptr_t n_reads;
  /**
   * Array of field IDs this propagator reads (previous tick).
   */
  const uint32_t *reads_previous;
  /**
   * Length of `reads_previous` array.
   */
  uintptr_t n_reads_previous;
  /**
   * Array of write declarations.
   */
  const struct MurkWriteDecl *writes;
  /**
   * Length of `writes` array.
   */
  uintptr_t n_writes;
  /**
   * Step function called each tick (must not be null).
   */
  int32_t (*step_fn)(void*, const struct MurkStepContext*);
  /**
   * User data pointer passed to `step_fn`.
   */
  void *user_data;
  /**
   * Scratch memory bytes required.
   */
  uintptr_t scratch_bytes;
} MurkPropagatorDef;

/**
 * Receipt returned to C callers for each command.
 */
typedef struct MurkReceipt {
  /**
   * Whether the command was accepted (1) or rejected (0).
   */
  uint8_t accepted;
  /**
   * Tick at which the command was applied (0 = not applied).
   */
  uint64_t applied_tick_id;
  /**
   * Reason code (MurkStatus value, or 0 for none).
   */
  int32_t reason_code;
  /**
   * Index of this command within the submitted batch.
   */
  uint32_t command_index;
} MurkReceipt;

/**
 * Retrieve the panic message stored by the most recent [`ffi_guard!`] catch
 * on this thread.
 *
 * - If `buf` is null, returns the full message length (in bytes) without
 *   copying anything. Returns `0` if no panic has been recorded.
 * - Otherwise, if `cap > 0`, copies up to `cap - 1` bytes into `buf`,
 *   null-terminates, and returns the full message length.
 * - If `cap == 0`, performs no writes and returns only the full message
 *   length.
 */
int32_t murk_last_panic_message(char *buf, uintptr_t cap);

/**
 * ABI version: major in upper 16 bits, minor in lower 16.
 *
 * Bump major on breaking changes, minor on additions.
 * Current: v2.1 (v2.0→v2.1: ffi_guard! panic safety, murk_last_panic_message, MurkStatus::Panicked)
 */
uint32_t murk_abi_version(void);

/**
 * Create a batched engine from N config handles and an optional obs spec.
 *
 * `config_handles`: array of N config handles (all consumed, whether success or error).
 * `obs_entries` + `n_entries`: obs plan entries (0 entries = no obs plan).
 * `handle_out`: receives the batched engine handle.
 */
int32_t murk_batched_create(const uint64_t *config_handles,
                            uintptr_t n_worlds,
                            const struct MurkObsEntry *obs_entries,
                            uintptr_t n_entries,
                            uint64_t *handle_out);

/**
 * Step all worlds and extract observations in one call.
 *
 * `cmds_per_world`: array of N pointers to MurkCommand arrays.
 * `n_cmds_per_world`: array of N counts.
 * `obs_output`: pre-allocated buffer, `N * per_world_obs_output_len` f32s.
 * `obs_mask`: pre-allocated buffer, `N * per_world_obs_mask_len` u8s.
 * `tick_ids_out`: array of N u64s for per-world tick IDs (may be null).
 */
int32_t murk_batched_step_and_observe(uint64_t handle,
                                      const struct MurkCommand *const *cmds_per_world,
                                      const uintptr_t *n_cmds_per_world,
                                      float *obs_output,
                                      uintptr_t obs_output_len,
                                      uint8_t *obs_mask,
                                      uintptr_t obs_mask_len,
                                      uint64_t *tick_ids_out);

/**
 * Extract observations from all worlds without stepping.
 */
int32_t murk_batched_observe_all(uint64_t handle,
                                 float *obs_output,
                                 uintptr_t obs_output_len,
                                 uint8_t *obs_mask,
                                 uintptr_t obs_mask_len);

/**
 * Reset one world by index.
 */
int32_t murk_batched_reset_world(uint64_t handle, uintptr_t world_index, uint64_t seed);

/**
 * Reset all worlds with per-world seeds.
 */
int32_t murk_batched_reset_all(uint64_t handle, const uint64_t *seeds, uintptr_t n_seeds);

/**
 * Destroy a batched engine.
 */
int32_t murk_batched_destroy(uint64_t handle);

/**
 * Number of worlds in the batch.
 *
 * Returns 0 for invalid handles.
 */
uintptr_t murk_batched_num_worlds(uint64_t handle);

/**
 * Per-world observation output length (f32 elements).
 *
 * Returns 0 for invalid handles or if no obs plan.
 */
uintptr_t murk_batched_obs_output_len(uint64_t handle);

/**
 * Per-world observation mask length (bytes).
 *
 * Returns 0 for invalid handles or if no obs plan.
 */
uintptr_t murk_batched_obs_mask_len(uint64_t handle);

/**
 * Create a new config builder. Returns handle via `out`.
 */
int32_t murk_config_create(uint64_t *out);

/**
 * Destroy a config builder, releasing its resources.
 */
int32_t murk_config_destroy(uint64_t handle);

/**
 * Set the spatial topology for the config.
 *
 * `params` is an array of `n_params` f64 values interpreted per space type:
 * - Line1D: \[length, edge_behavior\]
 * - Ring1D: \[length\]
 * - Square4/Square8: \[width, height, edge_behavior\]
 * - Hex2D: \[cols, rows\]
 * - Fcc12: \[w, h, d, edge_behavior\]
 * - ProductSpace: \[n_components, type_0, n_params_0, p0_0, ..., type_1, n_params_1, p1_0, ...\]
 *
 * Edge behavior: 0=Absorb, 1=Clamp, 2=Wrap.
 */
int32_t murk_config_set_space(uint64_t handle,
                              int32_t space_type,
                              const double *params,
                              uintptr_t n_params);

/**
 * Add a field definition to the config.
 *
 * `name` is a null-terminated C string.
 * `field_type`: 0=Scalar, 1=Vector, 2=Categorical.
 * `mutability`: 0=Static, 1=PerTick, 2=Sparse.
 * `dims`: components for Vector, n_values for Categorical, ignored for Scalar.
 * `boundary_behavior`: 0=Clamp, 1=Reflect, 2=Absorb, 3=Wrap.
 */
int32_t murk_config_add_field(uint64_t handle,
                              const char *name,
                              int32_t field_type,
                              int32_t mutability,
                              uint32_t dims,
                              int32_t boundary_behavior);

/**
 * Add a propagator to the config. Takes ownership of the propagator box.
 *
 * `prop_ptr` is a `Box<dyn Propagator>` as a raw pointer cast to u64
 * (from `murk_propagator_create`).
 */
int32_t murk_config_add_propagator(uint64_t handle, uint64_t prop_ptr);

/**
 * Set the simulation timestep in seconds.
 */
int32_t murk_config_set_dt(uint64_t handle, double dt);

/**
 * Set the RNG seed.
 */
int32_t murk_config_set_seed(uint64_t handle, uint64_t seed);

/**
 * Set the ring buffer size (minimum 2).
 */
int32_t murk_config_set_ring_buffer_size(uint64_t handle, uintptr_t size);

/**
 * Set the maximum ingress queue depth.
 */
int32_t murk_config_set_max_ingress_queue(uint64_t handle, uintptr_t size);

/**
 * Query per-propagator timing from the most recent step on this thread.
 *
 * Reads from the thread-local snapshot populated by `murk_lockstep_step`,
 * ensuring consistency with the aggregate `MurkStepMetrics` from the same
 * call. `world_handle` is accepted for API compatibility but unused — the
 * data comes from the thread-local buffer, not a world lock re-acquisition.
 *
 * `index` is 0-based. Writes the propagator name into `name_buf` (up to
 * `name_cap` bytes including null terminator) and its execution time
 * into `us_out`.
 */
int32_t murk_step_metrics_propagator(uint64_t _world_handle,
                                     uint32_t index,
                                     char *name_buf,
                                     uintptr_t name_cap,
                                     uint64_t *us_out);

/**
 * Retrieve latest metrics for a world.
 */
int32_t murk_step_metrics(uint64_t world_handle, struct MurkStepMetrics *out);

/**
 * Compile an observation plan against a world's space.
 *
 * Takes a world handle (for space access) and an array of observation entries.
 * Returns a plan handle via `plan_out`.
 */
int32_t murk_obsplan_compile(uint64_t world_handle,
                             const struct MurkObsEntry *entries,
                             uintptr_t n_entries,
                             uint64_t *plan_out);

/**
 * Execute an observation plan, filling caller-allocated output and mask buffers.
 *
 * `output` must have at least `murk_obsplan_output_len()` elements.
 * `mask` must have at least `murk_obsplan_mask_len()` bytes.
 */
int32_t murk_obsplan_execute(uint64_t world_handle,
                             uint64_t plan_handle,
                             float *output,
                             uintptr_t output_len,
                             uint8_t *mask,
                             uintptr_t mask_len,
                             struct MurkObsResult *result_out);

/**
 * Execute an observation plan for N agents, filling caller-allocated buffers.
 *
 * `agent_centers` is a flat array of `n_agents * ndim` i32 values.
 * `output` must have at least `n_agents * murk_obsplan_output_len()` elements.
 * `mask` must have at least `n_agents * murk_obsplan_mask_len()` bytes.
 * `results_out` may be null; if non-null, must point to `n_agents` results.
 */
int32_t murk_obsplan_execute_agents(uint64_t world_handle,
                                    uint64_t plan_handle,
                                    const int32_t *agent_centers,
                                    int32_t ndim,
                                    int32_t n_agents,
                                    float *output,
                                    uintptr_t output_len,
                                    uint8_t *mask,
                                    uintptr_t mask_len,
                                    struct MurkObsResult *results_out);

/**
 * Destroy an observation plan.
 */
int32_t murk_obsplan_destroy(uint64_t plan_handle);

/**
 * Query the output length (in f32 elements) of a compiled plan.
 *
 * Returns -1 if the handle is invalid or mutex is poisoned.
 */
int64_t murk_obsplan_output_len(uint64_t plan_handle);

/**
 * Query the mask length (in bytes) of a compiled plan.
 *
 * Returns -1 if the handle is invalid or mutex is poisoned.
 */
int64_t murk_obsplan_mask_len(uint64_t plan_handle);

/**
 * Create a propagator from a C definition.
 *
 * Returns a raw pointer (as `u64`) to be passed to `murk_config_add_propagator`.
 * The pointer is consumed exactly once; double-use is UB.
 */
int32_t murk_propagator_create(const struct MurkPropagatorDef *def, uint64_t *out_handle);

/**
 * Create a lockstep world from a config handle. Consumes the config.
 *
 * On success, writes the world handle to `world_out` and returns `MURK_OK`.
 * On failure, the config is still consumed (destroyed).
 */
int32_t murk_lockstep_create(uint64_t config_handle, uint64_t *world_out);

/**
 * Destroy a lockstep world, releasing all resources.
 */
int32_t murk_lockstep_destroy(uint64_t world_handle);

/**
 * Execute one tick: submit commands, run pipeline, return receipts + metrics.
 *
 * `cmds` is an array of `n_cmds` commands (may be null if `n_cmds == 0`).
 * `receipts_out` is a caller-allocated buffer of at least `receipts_cap` entries.
 * `n_receipts_out` receives the actual number of receipts written.
 * `metrics_out` may be null to skip metrics collection.
 */
int32_t murk_lockstep_step(uint64_t world_handle,
                           const struct MurkCommand *cmds,
                           uintptr_t n_cmds,
                           struct MurkReceipt *receipts_out,
                           uintptr_t receipts_cap,
                           uintptr_t *n_receipts_out,
                           struct MurkStepMetrics *metrics_out);

/**
 * Reset the world to tick 0 with a new seed.
 */
int32_t murk_lockstep_reset(uint64_t world_handle, uint64_t seed);

/**
 * Read a field from the current snapshot into a caller-allocated buffer.
 *
 * Returns `MURK_OK` on success, `MURK_ERROR_BUFFER_TOO_SMALL` if `buf_len`
 * is less than the field's element count, `MURK_ERROR_INVALID_ARGUMENT` if
 * the field ID is invalid.
 */
int32_t murk_snapshot_read_field(uint64_t world_handle,
                                 uint32_t field_id,
                                 float *buf,
                                 uintptr_t buf_len);

/**
 * Current tick ID for a world (0 after construction or reset).
 *
 * **Ambiguity warning:** returns 0 for both "tick 0" and "invalid handle."
 * Prefer [`murk_current_tick_get`] for unambiguous error detection.
 */
uint64_t murk_current_tick(uint64_t world_handle);

/**
 * Current tick ID with explicit error reporting.
 *
 * Writes the tick to `*out` and returns `MURK_OK`. Returns
 * `InvalidHandle` or `InternalError` without writing to `out`.
 */
int32_t murk_current_tick_get(uint64_t world_handle, uint64_t *out);

/**
 * Whether ticking is disabled due to consecutive rollbacks.
 *
 * **Ambiguity warning:** returns 0 for both "not disabled" and "invalid handle."
 * Prefer [`murk_is_tick_disabled_get`] for unambiguous error detection.
 */
uint8_t murk_is_tick_disabled(uint64_t world_handle);

/**
 * Tick-disabled state with explicit error reporting.
 *
 * Writes 1 (disabled) or 0 (enabled) to `*out` and returns `MURK_OK`.
 * Returns `InvalidHandle` or `InternalError` without writing to `out`.
 */
int32_t murk_is_tick_disabled_get(uint64_t world_handle, uint8_t *out);

/**
 * Number of consecutive rollbacks since the last successful tick.
 *
 * **Ambiguity warning:** returns 0 for both "zero rollbacks" and "invalid handle."
 * Prefer [`murk_consecutive_rollbacks_get`] for unambiguous error detection.
 */
uint32_t murk_consecutive_rollbacks(uint64_t world_handle);

/**
 * Consecutive rollback count with explicit error reporting.
 *
 * Writes the count to `*out` and returns `MURK_OK`. Returns
 * `InvalidHandle` or `InternalError` without writing to `out`.
 */
int32_t murk_consecutive_rollbacks_get(uint64_t world_handle, uint32_t *out);

/**
 * The world's current seed.
 *
 * **Ambiguity warning:** returns 0 for both "seed 0" and "invalid handle."
 * Prefer [`murk_seed_get`] for unambiguous error detection.
 */
uint64_t murk_seed(uint64_t world_handle);

/**
 * Seed with explicit error reporting.
 *
 * Writes the seed to `*out` and returns `MURK_OK`. Returns
 * `InvalidHandle` or `InternalError` without writing to `out`.
 */
int32_t murk_seed_get(uint64_t world_handle, uint64_t *out);

/**
 * Step multiple worlds sequentially. v1: no parallelism.
 *
 * If any world fails, returns the first error. All preceding worlds'
 * results are valid (receipts and metrics written).
 *
 * `receipts_out` is an array of `n_worlds` pointers to per-world receipt buffers
 * (or null to skip receipts). Each buffer must have capacity for the world's receipts.
 * `metrics_out` is an array of `n_worlds` MurkStepMetrics (or null to skip).
 */
int32_t murk_lockstep_step_vec(const uint64_t *world_handles,
                               const struct MurkCommand *const *cmds_per_world,
                               const uintptr_t *n_cmds_per_world,
                               uintptr_t n_worlds,
                               struct MurkStepMetrics *metrics_out);

#endif  /* MURK_H */
